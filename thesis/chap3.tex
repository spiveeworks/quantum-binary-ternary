% chap3.tex (Chapter 3 of the thesis)
\chapter[UNIVERSAL COMPUTATION]{Universal Computation}

A foundational result in quantum computation is that of universal computation, that certain combinations of quantum gate can be used to implement any quantum algorithm to some accuracy, given sufficient circuit depth. The resulting circuits are generally too long to use in practice, compared to compilation techniques that rely on specific properties of the algorithm in question, but the result is still useful since it proves that it's not impossible, i.e.\ its necessary and sufficient conditions provide a starting point for designing and using quantum computers in practice.

\section{Universal Computation in Qubit Contexts}
Universal computation for qubit computers is described in full detail in \cite{textbook}, based on the approach described in the paper \cite{universal-qubit}, [and the one it references, for permutation things] which requires only 3 gates to achieve universality:
\begin{align*}
	H_2 = \frac{1}{\sqrt{2}}\left[\begin{matrix}
		1 & 1 \\
		1 & -1
	\end{matrix}\right]
	\\
	T_2 = \left[\begin{matrix}
		1 & 0 \\
		0 & \frac{1}{\sqrt{2}}\left(1+ i\right)
	\end{matrix}\right]
	\\
	C_{p_0=1}(X_2) = \left[\begin{matrix}
		1 & 0 & 0 & 0 \\
		0 & 1 & 0 & 0 \\
		0 & 0 & 0 & 1 \\
		0 & 0 & 1 & 0 \\
	\end{matrix}\right]
\end{align*}
If a quantum computer has these operations available as elementary gates on every qubit in the system, and has $C(X)$ implemented as an elementary gate on enough pairs of qubits, so that $C(X)$ can be implemented indirectly for all remaining pairs, then this quantum computer will satisfy universal computation. In practice a quantum computer can implement more than just these operations, and doing so will generally allow more efficient implementation of quantum algorithms, but this set of 3 gates is a theoretically interesting sufficient condition for quantum universality.

Although quantum universality is ultimately a way of arranging these gates into algorithms that approximately implement some unitary operation, the algorithm itself is easier to describe in the reverse direction, decomposing a given unitary operation into sequences of increasingly basic operations.

In full detail the process has 7 steps:
\begin{enumerate}
	\item Unitary into unitaries on axis aligned planes
	\item axis aligned plane unitary into multi-controlled operation on any qubit + 2 copies of a transposition
	\item transposition into controlled operations by Gray codes
	\item controlled operations into Toffoli + single control operation
	\item Toffoli gate into $C(V)$ where $V^2 = X$
	\item single control operation into $AC(X)BC(X)C$
	\item single qubit operation into sequence of $H$, $T$ operations
\end{enumerate}
We will later extend this process to work for systems with at least one qubit, and any number of qutrits, so long as controlled increment operations $C_{p_i=1}(X)$ are also available between qutrit-qutrit pairs, and qubit-qutrit pairs. Since we assume to have a qubit available, we can leverage the same structure as described above, and in doing so avoid thinking about the geometry of the qutrit state space altogether. As a result the only steps that require our modification are steps 3 and 4, so we shall describe how they work in the qubit case here, for the rest of the steps the sources \cite{textbook} and \cite{universal-qubit} explain in plenty of detail.
\subsection{Decomposing Transpositions}
A transposition is a permutation that swaps two elements of a set, but leaves all other elements unchanged, and so when we say transposition in the context of quantum computation we mean a linear operation that swaps two computational basis states, and leaves the others unchanged, i.e. the linear extension of
\[S_{p_1\dots p_n, q_1\dots q_n}(\ket{r_1}\dots\ket{r_n}) = \begin{cases}
	\ket{p_1}\dots\ket{p_n} & \text{if\ } r_i = q_i \forall i \in \mathbb{Z}, 1 \leq i \leq n \\
	\ket{q_1}\dots\ket{q_n} & \text{if\ } r_i = p_i \forall i \in \mathbb{Z}, 1 \leq i \leq n \\
	\ket{r_1}\dots\ket{r_n} & \text{otherwise}
\end{cases}
\]
For example in a system with 2 qubits the transposition $S_{10,11}$ is simply the controlled not operation $C_{p_1 = 1}(X)$.

We also write $S_{p_i, q_i}$ rather than the full $S_{p_1\dots p_n, q_1\dots q_n}$ when possible.

[later, for ternary and mixed systems: We also take $S_{0,1}$, $S_{1,2}$, and $S_{0,2}$ to be defined operations acting on a single qutrit, and further define $S_{0,1} = X_2$ acting on single qubits, even in composite systems where other operations exist.]

In step 2 of the process described earlier, we needed transpositions in order to transform one of the axes of an axis aligned plane into an axis whose indices match the other axis, except for one qubit index, which we shall take to be the first object in the system. (though this may be less efficient than other choices) In other words we have some pair of computational basis states $\ket{1-p_1}\ket{p_2}\dots\ket{p_n}$ and $\ket{q_1}\dots\ket{q_2}$ upon which the original unitary was acting, and as such we would like to generate a transposition that swaps $\ket{p_1}\dots \ket{p_n}$ with $\ket{q_1}\dots\ket{q_n}$ so that the plane unitary now acts only on $\ket{1-p_1}\ket{p_2}\dots \ket{p_n}$ and $\ket{p_1}\ket{p_2}\dots \ket{p_n}$.

In order to implement these transpositions, the first step is to decompose them using what are called Gray codes, sequences of bit strings where each bit string differs from its neighbours by only by a single digit. Put more formally, we implement $S_{p_i,q_i}$ by induction on the number of indeces $i$ where $p_i \neq q_i$. If there are no states where they differ then $S_{p_i,q_i} = I$ so there is nothing to be done. If they differ by only one state, i.e. $p_j = 1 - q_j$, then the transposition is exactly the controlled-increment operation $C_c(X_j)$ where $c$ is the following set of condition vectors:
\begin{align*}
	c &= \{\ket{r_1}\dots\ket{r_n}\ |\ r_i = p_i = q_i \text{\ whenever\ } i \neq j\}
	\\&= \{\ket{p_1}\dots\ket{p_n}, \ket{q_1}\dots\ket{q_n}\}
\end{align*}

In the inductive case where there is more than one value $i$ for which $p_i$ and $q_i$ differ, we can pick just one, call it $j$, and decompose $S_{p_i, q_i}$ into two transpositions $S_{p_i, p'_i}S_{p'_i, q_i}$ defining
\[p'_i = \begin{cases}
	q_i = 1 - p_j & \text{if\ } i = j \\
	p_i & \text{otherwise}
\end{cases}\]
Then we have $S_{p_i, p'_i} = C_c(X_j)$ similar to above, and $S_{p'_i, q_i}$ as some product of such controlled operations by the inductive hypothesis.

[would be clearer to have a lemma: $S_{(p_i), (p'_i)}S_{(p'_i), (q_i)}=S_{(p_i), (q_i)}$]

At this point we will have decomposed some unitary acting on a plane, into as many as $2n$ multi-controlled increment operations, sandwiching a single multi-controlled unitary acting on some qubit. Our next step will be to decompose all of these multi-controlled unitaries into Toffoli gates sandwiching a single-controlled unitary.

\subsection{Multi-control Gates}
We would like to implement a controlled operation $C_c(U_j)$ with a very strict control condition, specifying the value of every single qubit in the system except for the target qubit with index $j$. In general it is hard enough to implement elementary gates that act on 2 or 3 qubits, and even then it is rare that a quantum computer will be able to implement these for arbitrary combinations of qubits, so we definitely need to decompose these multi-controlled operations in order to work with any realistic elementary gate set.

The approach is to introduce $n-2$ auxiliary qubits to the system, indexed $n+1$ through $2n-2$, which begin and end this process in the computational basis state $\ket{0}$. We then use these auxiliary qubits to check an increasing number of our condition qubits, the first auxiliary qubit state $r_{n+1}$ will indicate whether $r_1$ and $r_2$ are both in the desired states $p_1$ and $p_2$ respectively. The second will indicate the first 3, up until the final auxiliary state $r_{2n-2}$ which indicates whether all $n-1$ qubits apart from $r_j$ are in the correct state. At this point we can implement the desired gate as $C_{r_{2n-2}=1}(U_j)$, and then undo the process of setting $r_{n+1} \dots r_{2n-2}$ so that they may be used again.

The key to this process is the Toffoli gate, which is simply a controlled $X$ operation with two control bits, $C_{r_{i_1}=p_{i_1},r_{i_2}=p_{i_2}}(X_j)$

Once again our formal description will be inductive. Take $I$ to be the set of indeces $i$ for which our control operation $C_c(U_j)$ has a constraint $r_i = p_i$, so that
\[c = \{\ket{r_1}\dots\ket{r_n}\ |\ r_i = p_i \text{\ whenever} i \in I\}\]
Then we shall perform induction on the size of $I$, implementing any control operation as $2\ord{I}-2$ Toffoli gates, sandwiching a single control operation $C_{r_k=p_k}(U_j)$. When $I$ is a singleton set $\{k\}$, then we introduce no auxiliary bits, and simply yield the operation $C_{r_k=p_k}(U_j)$ as is. Otherwise, we choose two indeces $i_1$ and $i_2$ from $I$, introduce an auxiliary qubit $r_k$ which starts and ends in the state $\ket{0}$, and reduce $I$ to
\[I' = (I \backslash \{i_1, i_2\})\cup \{k\}\]
Correspondingly, define $p_k = 1$ and reduce the condition set $c$ to
\[c' = \{\ket{r_1}\dots\ket{r_n}\ |\ r_i = p_i \text{\ whenever} i \in I'\}\]
Now we simply put all of these constructions together, reducing as
\[C_c(U_j) = C_{r_{i_1}=p_{i_1},r_{i_2}=p_{i_2}}(X_k)
C_{c'}(U_j)
C_{r_{i_1}=p_{i_1},r_{i_2}=p_{i_2}}(X_k)\]
Since the middle of these is a controlled operation with a smaller index set $I'$, we can invoke the inductive hypothesis, decomposing $C_c(U_j)$ as required.

As a small optimization, if $U_j$ is the increment operation $X_j$ then we can implement $C_c(X_j)$ directly as $2\ord{I} - 3$ Toffoli gates, by taking as a base case $\ord{I} = 2$ where $C_c(X_j)$ is already a Toffoli gate, saving one controlled operation and one Toffoli gate.
\subsection{Multi-Valued Logic}
When the final operation $U_j$ in the above decomposition acts on a qutrit or higher, rather than a qubit, the remaining steps become much more difficult, simply because the geometry of $U(n)/U(1)$ is more complicated than that of $U(2)/U(1)$. In order to overcome this the paper \cite{multi-valued-logic} uses a different approach, by outlining a way of implementing a family of gates with arbitrarily many elements, depending on the required accuracy of implementation, and presents a separate proof that this family of gates is universal.

The family of gates they describe and utilize are a generalization of the controlled $X$ and controlled $Z$ gates, in a $d$-dimensional quantum computer, the following:
\[\Gamma X(\ket{\phi}) = C_{p_1 = d-1}(\ket{d-1}\bra{\phi} + \dots)\]
\[\Gamma Z(\theta) = C_{p_1 = d-1}\left(e^{i\theta}\ket{d-1}\bra{d-1} + \dots\right)\]
That is, the $\Gamma X$ family conditionally maps some state $\ket{d-1}\ket{\phi}$ to $\ket{d-1}\ket{d-1}$, and the $\Gamma Z$ family applies some relative phase factor to the state $\ket{d-1}\ket{d-1}$. When the control object is in state $\ket{d-1}$ the effect on all other states are arbitrary, so long as the resulting operation is unitary. When the control object is not in state $\ket{d-1}$ the operation has no effect.

This paper is a very promising theoretical and practical foundation for working with quantum systems with multiple objects all of one arbitrary dimension, especially systems based on the linear ion trap, but due to how different its approach is to ours, we only take one thing from it, which is a way of decomposing control operations $C_c(U_j)$ using auxiliary qutrits (or higher) instead of auxiliary qubits.

The process is identical to what we just described using Toffoli gates, except by introducing an auxiliary qutrit with index $k$, as opposed to the qubit with index $k$, and defining $p_k = 2$, we can use two single-controlled increments instead of one double-controlled (i.e.\ Toffoli) gate:
\[
C_c(U_j) = C_{r_{i_1}=p_{i_1}}(X_k)^{-1}
C_{r_{i_2}=p_{i_2}}(X_k)^{-1}
C_{c'}(U_j)
C_{r_{i_2}=p_{i_2}}(X_k)
C_{r_{i_1}=p_{i_1}}(X_k)
\]
Since $X_k$ is an increment operation acting on a qutrit, it will not be involutory the way that a qubit increment is, so we need to invert it explicitly. [Muthukrishnan used transpositions, and we will be using transpositions as well, so we should move the single-object transpositions up to this section or earlier, and change this to C(S) instead of C(X). Then have a note about how you could use C(X) instead if that is available more directly, since we will eventually implement C(S) in terms of C(X). maybe that note should go in chapter 3 when we make that implementation of C(S)?]

In \cite{multi-valued-logic} this was done more efficiently, effectively setting $p_k = d-1$ rather than $p_k = 2$, and performing $d-1$ separate controlled operations for each auxiliary object added, but since we only consider qutrits this is equivalent.
\section{Universality of Composite Systems}
Earlier we outlined how 7 techniques can be used in order to decompose any unitary in $U(N)$ into an approximating series of gates from the finite generator set $\{H, T, C(X)\}$. In order to make sense of computation in mixed systems we ought to propose at least one gate set that is universal. Recall our definition of transposition matrices:
\[S_{p_1\dots p_n, q_1\dots q_n}(\ket{r_1}\dots\ket{r_n}) = \begin{cases}
	\ket{p_1}\dots\ket{p_n} & \text{if\ } r_i = q_i \forall i \in \mathbb{Z}, 1 \leq i \leq n \\
	\ket{q_1}\dots\ket{q_n} & \text{if\ } r_i = p_i \forall i \in \mathbb{Z}, 1 \leq i \leq n \\
	\ket{r_1}\dots\ket{r_n} & \text{otherwise}
\end{cases}
\]
This definition works as-is for arbitrary composite systems, which will be useful for our generalization, but we also define $S_{p,q}$ [suddenly realizing I use $\ket{i}$ and $\ket{j}$ for single systems... if I switch to a consistent notation I will need to switch to $p$ and $q$ as well!] acting on single objects within a composite system:
\[S_{p, q}\ket{r} =
\begin{cases}
	\ket{p} & \text{if\ } r = q \\
	\ket{q} & \text{if\ } r = p \\
	\ket{r} & \text{otherwise}
\end{cases}
\]
[ambiguous vs $S_{p_i, q_i}$... maybe $S_{(p_i),(q_i)}$?]

Then our first goal is to prove [theorem?] that any unitary matrix acting on some composite system, $U \in U(N) = U(\prod_i d_i)$, with at least one qubit, i.e.\ some $j$ such that $d_j = 2$, that the gate set $\{H, T\} \cup \{S_{p,q}\} \cup \{C(S_{p,q})\}$ is universal.

We have from existing qubit literature that such a matrix can be decomposed into unitaries acting on various axis aligned planes, which can then be decomposed into multi-controlled operations $C_c(U_j)$ acting on some qubit, sandwiched by transpositions $S_{(p_i),(q_i)}$. Now we follow much the same procedure as before, but instead of only having the single transposition $S_{0, 1} = X_2$ to work with, we work with general transpositions $S_{p, q}$.

First recall the algorithm for decomposing a transposition into controlled increments, which we generalize by simply decomposing into controlled transpositions. [I should probably use the term NOT, so that it is more intuitive how control increment and control transposition are both generalizations of control NOT] If $p_i = q_i$ for all $i$ except one $i = k$, then $S_{(p_i), (q_i)}$ is already a controlled operation $C_c(S_{p_k,q_k})$. If $p_i$ and $q_i$ differ by more than one value then decompose into two transpositions $S_{(p_i), (p'_i)}S_{(p'_i), (q_i)}$ and then inductively turn each one into a series of controlled transpositions.

Now the way that we decompose the controlled objects depends on the dimension of our auxiliary objects. If there are auxiliary qutrits or higher then we can use the decomposition we derived from \cite{multi-valued-logic}, reducing the size of the control set via
\[
C_c(U_j) = C_{r_{i_1}=p_{i_1}}(S_{0,1})
C_{r_{i_2}=p_{i_2}}(S_{1,2})
C_{c'}(U_j)
C_{r_{i_2}=p_{i_2}}(S_{1,2})
C_{r_{i_1}=p_{i_1}}(S_{0,1})
\]
Otherwise if there are only auxiliary qubits available we can use the Toffoli decomposition, with a target qubit and two control objects that could be of any dimension. The gate would still be written $C_{r_{i_1}=p_{i_1},r_{i_2}=p_{i_2}}(X_j)$. [implementing this double-controlled gate would require some elaboration, I'll need to explain the circuit for implementing Toffoli using $C(\sqrt{X})$ and generalize that. Also implementing $C(U_j)$ in terms of $C(X)$ needs some explanation! It's just the first two and the last steps that stay the same. It would also be good to explain how in binary $S_{0,1} = X_2 = HT^4H$, and $C_{p=0}(U_j) = X_pC_{p=1}(U_j)X_p$, in fact does the basis need $S_{p,q}$? or just $C_{r_i=d_i-1}(S_{p_j,q_j})$ and $X_i$...]

This is a straight forward generalization of the universality result for qubits, but requires a lot of different permutation matrices in order to be complete, so while the above argument is generic to any composite system, it is not that useful by itself. We do not stop here, however; by specifying that all objects are qubits or qutrits we can make further decompositions and get a set of 5 gates. [note somewhere that this isn't proven to be minimal, it's meant to be enough to work with]
\section{Analysing Small Permutations}
We have reduced $U(N)$ to a finite number of generator elements we would like to target. By setting $d_i \in \{2, 3\}$ we have a generator of 12 operations, 4 single object operations
\[H_2, T, X_2, X_3\]
and 8 permutation matrices acting on pairs of objects
\[C_2(X_2), C_2(S_{0,1}), C_2(S_{0, 2}), C_2(S_{1, 2}), C_3(X_2), C_3(S_{0, 1}), C_3(S_{0, 2}), C_3(S_{1, 2})\}\]
where $C_2(\dots)$ is taken to constrain some qubit to the value 1, and $C_3(\dots)$ some qutrit to the value 3. [could define this explicitly in notation section, $C_2$ and $C_d$ also]

We can construct $X_2$ in the usual way, as $H_2T^4H_2$, so we can remove this from the generator set. Further when a matrix $A_j$ acts on the target digit, and hence has no effect on the control digit of a control operation $C_c(B_j)$ we can make many reductions using the relation
\[A_jC_c(B_j)A_j^{-1} = C_c(A_jB_jA_j^{-1})\]
Since when the condition is not satisfied the left hand side will have the effect of $A_jIA_j^{-1}$ i.e.\ no effect, just like the right hand side, and when the condition is satisfied both sides will have the effect $A_jB_jA_j^{-1}$.

[why not just explicitly take all these gates to act on hypothetical 2-object systems from now on, either $\mathbb{C}^4$, $\mathbb{C}^6$, or $\mathbb{C}^9$]

This lets us remove most of the control objects targeting qutrits:
\begin{align*}
	C_d(S_{0, 2}) = C_d(X_3^{-1}S_{0,1}X_3) = X_3^{-1}C_d(S_{0,1})X_3
	\\
	C_d(S_{1, 2}) = C_d(X_3S_{0,1}X_3^{-1}) = X_3C_d(S_{0,1})X_3^{-1}
\end{align*}
We have now reduced our generator set to 7:
\[H_2, T, X_3, C_2(X_2), C_2(S_{0, 1}), C_3(X_2), C_3(S_{0, 1})\]

It is hard to speculate on what a good generator would be without properly considering the physical constraints and trade-offs of a specific computer, but it would not be surprising if $C_2(X_3)$ was more favourable to implement than $C_2(S_{0, 1})$, [suddenly realizing that when turning 2-level unitary into controlled operation we could have used any permutation! which means I could have targeted $C(X)$ from the start! I should consider drawing out the entire discussion of universality into parallel discussions of transposition vs incrementation, since they seem equivalent at every level, not just this one.] and while it is easy to implement $C_d(X_3)$ as $C_d(S_{0,1})C_d(S_{1,2})$, [this is another neat control identity to generalise] it isn't obvious how the reverse might be done. We will later find by brute force that
\[C_2(S_{0,1}) = C_3(X_2) C_2(X_3)^{-1} C_3(X_2) C_2(X_3) C_3(X_2)\]

A decomposition that is likely much less useful than the above is that we can implement $X_3$ as $X_2C_2(X_3)X_2C_2(X_3)$, which increments a qutrit on the condition that a qubit is $\ket{1}$, and then flips that qubit before repeating, ultimately incrementing the qutrit regardless of the state of the qubit. We are going to assume that $X_3$ is significantly easier to implement than $C_2(X_3)$, since $X_3$ only acts on one object, and is not only Clifford, but Pauli, and hence will almost always be implemented before any other operations in the target quantum computer.

This means we have one of two generator sets, either the transposition based set
\[\{H_2, T, X_3, C_2(X_2), C_2(S_{0, 1}), C_3(X_2), C_3(S_{0, 1})\}\]
or the increment based set
\[\{H_2, T, X_3, C_2(X_2), C_2(X_3), C_3(X_2), C_3(X_3)\}\]
[we haven't given an argument for $C_3(S_{0,1})$ in terms of $C_3(X_3)$, hopefully I'll start using increments the whole way through the universality argument, but otherwise you can use an auxiliary qubit and do $C_3(X_2)C_2(S_{0,1})C_3(X_2)$]

Either way we would have 7 gates to implement and then work with. All of the examples we have seen of universal computation for qubits or qutrits has involved some number of Clifford gates, and a single non-Clifford gate, but in order to generalize the standard binary model of quantum computation we find we require 3 additional control gates, none of which are Clifford. [I should probably show that $C_3(X_3)$ is not Clifford..........] As we saw in \cite{tolar-clifford}, there are no Clifford operations that act dependently between a qubit and a qutrit, so it is not clear how easy or valuable it would be to minimize the number of non-Clifford gates used in a mixed logic systems. This prompts a search for other finite groups that act on mixed qubit-qutrit systems.
