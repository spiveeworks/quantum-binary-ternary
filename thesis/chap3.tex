% chap3.tex (Chapter 3 of the thesis)
\chapter[CALCULATION IN BINARY-TERNARY]{Calculation in Binary-Ternary}

\section{Notation for Mixed Systems}
[move to preliminaries and make sure that I am actually using this notation]

A very ergonomic notation for gates in quantum algorithms is to subscript the gate with relevant information about that gate such as the dimension of the object or system on which it acts, the index of the individual object or part of the composite system on which it acts, or the computational basis states that it affects.

Many discussions of quantum algorithms vary only one property of a given quantum gate at a time, making this notation unambiguous. Unfortunately we must have gates acting on distinct objects of a composite system, each with a dimension that could be different, which requires us to take extra care. Lest we lose the ergonomics of putting all the necessary information in small and descriptive subscripts, we continue to place variables in these subscripts, but avoid numerals unless the meaning is clear. We will now enumerate in advance the exact index sets that could be used for a variable in a subscript, a preferred letter in the alphabet for representing such a variable, and what that subscript means when this variable is used.

In composite quantum systems we define $N$ to be the number of computational basis states, and either $n$ to be the number of individual objects in the composite system, or $n$ to be the number of qubits and $m$ to be the number of qutrits. For example we could use these variables to index the Quantum Fourier Transform $\text{QFT}_N$ or a general unitary matrix $U_N$ acting on $N$ computational basis states, or $H^{\otimes n}$ for the Kronecker product of the $H$ matrix with itself $n$ times.

In quantum systems of a single finite-dimensional object we instead call the dimension of this object $n$, and index each of the computational basis states $0$ through to $n-1$, represented by variables such as $i$, $j$, and $k$. For example we will frequently distinguish between $X_2$, $X_3$, and generally $X_n$ in the context of a single quantum object. This is the one case where we will use both numerals and variables for subscripts, since we very often want to say specific things about the $n=2$ and $n=3$ cases.

Note that we change the meaning of $n$ based on context, for the sole purpose of reminding ourselves of the cyclic group formed by the set $\mathbb{Z}_n = \mathbb{Z}/n\mathbb{Z}$ equipped with addition, a very familiar object which appears repeatedly in finite groups of quantum gates acting on single quantum objects.
[do we actually talk about single objects outside of the preliminary discussion of Pauli matrices? Won't know until later in semester]

When we want to talk about an individual object in a composite system, we index each object $1$ through to $n$, (or $1$ through to $n+m$) and use variables such as $p$, $q$, and $r$ to represent such an index. We then define $d_p$ to be the dimension of the object indexed by $p$. This allows us to extend some unitary matrix $G_d$ acting on a single quantum object of dimension $d$ to a unitary matrix $G_p$ acting on some composite system satisfying $d_p = d$. Written as a Kronecker product, $G_p$ looks like the following:
\[G_p = I_{d_1}\otimes \dots \otimes I_{d_{p-1}} \otimes G_d \otimes I_{d_{p+1}} \otimes \dots \otimes I_{d_n}\]

When indexing computational basis states in a composite system, we use the integers $0$ through to $N-1$ much like in single systems, [unless I removed that paragraph/notation] and variables such as $i$, $j$, and $k$ to represent such indeces. This is particularly useful for the special class of permutation matrices that represent a transposition, where we can write $S_{i,j}$ to represent the matrix that exchanges the computational basis states $\ket{i}$ and $\ket{j}$, while leaving all others unchanged.

When we introduce a variable such as $i$, satisfying $0 \leq i \leq N-1$, we assume implicitly that the sequence of digits $i_1i_2\dots i_p \dots i_n$ exists and that each variable $i_p$ is understood to refer to the corresponding digit in this sequence. We also identify all such integers $0\dots N-1$ with their corresponding sequences of digits whenever we discuss the computational basis states.

When we have a unitary matrix $U$ acting on a composite system with $N$ computational basis states, and a set $c \subseteq \{0\dots N-1\}$, our final subscript notation will be to define the controlled operation $C_c(U)$ which has the following action on the computational basis:
\[C_c(U)\ket{i} = \begin{cases}
U\ket{i} & \text{if\ }i \in c \\
\ket{i} & \text{if\ }i \notin c
\end{cases}\]
Note that in order for $C_c(U)$ to be unitary, it is sufficient that the image $U\ket{i}$ of any computational basis vector $\ket{i}$ satisfying $i \in c$ be a linear combination of basis vectors $\ket{j}$ themselves satisfying $j \in c$. For example if we have a gate $G_p$ acting only on object $p$ of the system, then $C_c(G_p)$ will be unitary whenever $c$ is a set whose defining predicate $i_1\dots i_n \in c$ does not depend on the digit $i_p$.

When we have a condition 

Finally when $G_d$ is a unitary matrix acting on a $d$-dimensional object, and $G_p$ is the corresponding matrix acting on object $p$ of a composite system, it is sometimes useful for the set $c$ to impose a constraint on all but $d$ of the computational basis states of the composite system, in which case we can write $C_c(G_d)$ instead of $C_c(G_p)$.
\section{Universality of Composite Systems}
Shall discuss decomposing operations by describing how arbitrary elements of a large set of matrices can be implemented by composing elements of a smaller set of matrices.

Arbitrary unitary into 2 level unitaries
\\into transpositions + controlled unitary
\\into local transpositions + arbitrary qubit unitary
\\toffoli into local transpositions as well using square root of $S$
\section{Universality for Classical Calculations}
many local transpositions are equivalent up to single object permutation
\\controlled qutrit operations are equivalent up to single object + controlled qubit
\\non-mixed controlled operations can be implemented using these mixed ones, or directly using standard gate sets in sparse practical contexts
\\single object permutation + controlled qubit + controlled qutrit is clearly universal for classical, via the previous argument/gray codes
\\throw in single qubit unitaries and you get asymptotic universality as well
\section{Porting Ternary Arithmetic to Mixed Systems}
have found a useful set of basic gates for mechanized compilation
\\let's look at specific algorithms that have been designed rather than compiled
\\\cite{arithmetics} implements ternary addition as a permutation on computational basis states
\\the ripple carry is designed so that the carry digit is always binary, which could be implemented in a mixed context
\\(possibly draw up a circuit implementing the carry operations)
\\the look ahead carry has ternary carry registers, but could be used for binary arithmetic, again giving a mixed algorithm
\\(possibly draw up circuit for this as well)
\\either of these would have less entropy than the pure ternary case, but many practical tradeoffs may render pure ternary to be superior, such as connectivity requirements, performance costs of mixed logic in general
\\we have access to any method, lot of flexibility! add bits or trits with bit carry or trit carry
\\(possibly mention mixed-string representations, here or in final discussion)
\section{Clifford Operations}
Bocharov et al. use non-clifford operations to measure the depth of their circuits, since these are the operations that will need asymptotic decomposition analogous to our arbitrary qubit operations.
\\Clifford operations are powerful but form a simple and elegant finite group, with many uses in information and computation theoretic contexts (maybe this is calling back to background content)
\\by \cite{tolar-clifford} we see that the Clifford operations available in mixed systems with objects of coprime dimension are simply the Clifford operations available in each individual object, so none of our controlled operations are Clifford!
\\For a group to have some of the same power that the Clifford group has in computational contexts, we should want all of the following:
\begin{itemize}
	\item finite
	\item can map computational basis to non-computational basis
	\item can alter a qutrit dependant on a qubit and vice versa
\end{itemize}
Look at $6\times 6$ unitary matrices acting on a single qubit and a single qutrit
\\Looking at $H_3 \times CX_2$ and $H_2 \times CX_3$ we see both are infinite order?? (haven't proven yet)
\\$H_2 \times CS_3$ is finite order but $H_2 \times X_3 \times CS_3$ is infinite order as well.
\\By previous equivalence statements that means that any finite group which has both Fourier transforms will fail to implement the controlled operations we need
\\(possibly mention the quantum information implications of these gates, again maybe discussion)
\\this probably means that Clifford + $CX_2$ + $CX_3$ is universal however

$C(X_3)\ H_2\ C(X_3)\ H_2$:
\[\left[\begin{matrix}
1/2 & 0 & 1/2 & 1/2 & 0 & -1/2\\
1/2 & 1/2 & 0 & -1/2 & 1/2 & 0\\
0 & 1/2 & 1/2 & 0 & -1/2 & 1/2\\
0 & -1/2 & 1/2 & 0 & 1/2 & 1/2\\
1/2 & 0 & -1/2 & 1/2 & 0 & 1/2\\
-1/2 & 1/2 & 0 & 1/2 & 1/2 & 0
\end{matrix}\right]\]
Entering this directly into Wolfram Mathematica we get the following characteristic polynomial:
\[1/4 (\lambda - 1)^2 (4 \lambda^4 + 2 \lambda^3 - 3 \lambda^2 + 2 \lambda + 4)\]
Since the main factor of this polynomial is irreducible, but not monic/integral, we can conclude that this matrix has eigenvalues that aren't roots of unity, much like the $Z^{\frac{1}{4}}X^{\frac{1}{4}}$ matrix used in \cite{universal-qubit} and \cite{algos}, meaning this matrix and any group containing it must be infinite order.



\section{Programmatic Search for Finite Groups}
finitely generated groups, can search programmatically
\\can implement permutations as a lookup table, simple linear array of memory
\\can implement matrices as arrays as well
\\floats are not viable for this algebraic/symbolic problem, need exact comparison of square roots of numbers
\\Mathematica would be suitable, but implementing the data type in C is easy enough, and as a bonus lets us explicitly manage the time and memory that these combinatoric group structures rapidly consume
\\The 2x2 and 3x3 Fourier transforms require representation of $\sqrt{2}$ and $\sqrt{3}$, in addition to $i = \sqrt{-1}$. The typical representation of a complex number is as a pair of real numbers, and iterating this process we can represent such a number as 8 rational numbers. Collecting the denominator we end up with 9 integers.
\\The set of real numbers that can be represented in this way (ignoring integer overflow) is closed under addition and multiplication, so we can multiply matrices of these numbers
\\algorithm is to treat these numbers as polynomials of 3 variables, then reduce down the quadratic terms
\\search algorithm is breadth first, but the output of the search is also the queue for which elements to search next
\\for each new group element, compose it with each of the generators, and whichever of them are new get added to the list
\\a quick implementation of a hash table can reduce the time taken to compare new group elements
\\robin hood addressing is an interesting hash-table addressing scheme, and is high performance both in speed and memory, perfect for group search
\\custom 

Call the group generated by X, Z, D the 'reduced Clifford group', RCG + H2 + H3 is the clifford group of course, which we confirm to be finite
\\RCG + H2 + CX2 and RCG + H3 + CX3 are also finite
\\RCG + CX2 + CX3 starts to use a lot of memory, but it has all of the permutations, and everything else is diagonal, so it ends up being a semidirect product of $\mathbb{Z}_6^6$ and $\mathcal{S}_6$.
\\to find the infinite order H2 CX3 and H3 CX2 terms we attempt to calculate the order of all terms we find, and record any that lead to an integer overflow when raised to some power.
\\only 24 permutation matrices did not have this property with either H2 or H3, 12 of which were the trivial Clifford permutations we already had, and 12 of which could be used to generate the $H_2 X_3 CS_2$ matrix which is itself infinite order.
\\From this it seems likely that no group can have both Fourier transforms and any additional non-clifford permutation while being finite, but this shouldn't be surprising.

\section{Discussion}
We have found that having access to the 2- and 3-dimensional Fourier transforms, along with any permutation that acts dependently on a qubit-qutrit pair, seem to be enough to produce infinite order operations, and in particular we found the gates $H_2 C(X_3)$ and $H_3 C(X_2)$ are infinite order. This means that $C(X_2)$ and $C(X_3)$ are analogous to the phase gate $Z^{\frac{1}{4}}$ in that they are finite order but with a Fourier transform become infinite order. It was seen in \cite{universal-qubit} that the phase gate and the Fourier transform are therefore universal for single qubit operations, which may have an analogue for mixed-logic using these gates, meaning that the same gates we use to implement permutations are likely universal as well when combined with the Clifford operations. [Clifford+1 maybe this is obvious? not sure whether that result is dimension-specific or not general]

Additionally there is a technique called magic state distillation which uses repeated transformation and measurement to approximate states that are normally only available using non-Clifford gates such as the phase gate, which when available can be used to implement the phase gate directly. Analogous to this we can construct states with these Fourier transformations, controlled operations, and measurement that can't be constructed using Clifford gates alone. [allude to other states or to techniques for using these states, worth exploring but I don't know how to do any of it. also show how to construct the embedded + state.]