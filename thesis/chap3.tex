% chap3.tex (Chapter 3 of the thesis)
\chapter[UNIVERSAL COMPUTATION]{Universal Computation}

A foundational result in quantum computation is that of universal computation, that certain combinations of quantum gate can be used to implement any quantum algorithm to some accuracy, given sufficient circuit depth. The resulting circuits are generally too long to use in practice, compared to compilation techniques that rely on specific properties of the algorithm in question, but the result is still useful since it proves that it's not impossible, i.e.\ its necessary and sufficient conditions provide a starting point for designing and using quantum computers in practice.

\section{Universal Computation in Qubit Contexts}
The two most widely useful results about universality of qubit computers are the result of \cite{cnot-decomposition}, that a quantum computer with arbitrary operations from $U(2)$ on each individual qubit, and the controlled not $C(X)$ operation, one can exactly implement any unitary $U \in U(N)$, and the result of \cite{universal-qubit}, which ports this result to fault tolerant computation by showing that with only two fault tolerant elementary gates one can approximate any single-qubit operation in $U(2)$, and hence with the addition of $C(X)$, which is also fault tolerant, one can fault tolerantly approximate any operation in $U(N)$. We shall describe the former of these results, and in doing so generalize it to the following:

[Theorem] In any mixed quantum computer with at least one qubit, one can achieve universal computation with either:
\begin{itemize}
	\item Arbitrary qubit operations and arbitrary controlled increments $C_{r_i=q_i}(X_{d_j})$
	\item Arbitrary qubit operations and arbitrary controlled transpositions $C_{r_i=q_i}(S_{p_i,p'_i})$
\end{itemize}
[I define $S_{p,q}$ after this point so... should move those definitions up to the notation section]

In the case of a computer with only qubits, this theorem is equivalent to the result of \cite{cnot-decomposition}. We shall now outline the series of techniques presented in the textbook \cite{textbook}, which collect the relevant techniques from \cite{cnot-decomposition} and its predecessors into a continuous sequence of increasingly powerful proofs of universal computation. We will treat this as a single proof, with each step of the proof decomposing an arbitrary unitary $U \in U(N)$ into a smaller set of basic operations. The first decomposition is of $U$ into
\[U = \prod_{p=0}^{N-2}\prod_{q=p+1}^{N-1}U_{p,q},\]
giving $(N-1)(N-2)/2$ unitary matrices $U_{p,q}$, one for each distinct pair $p = p_n\dots p_1$, $q = q_n\dots q_1$, $p < q$. [need to define these digital expansions instead of the $\ket{p_n}\dots\ket{p_1}$ thing I thought I would use] Specifically $U_{p,q}$ will be `two level' unitaries, in that they only act on the two computational basis vectors $\ket{p}$ and $\ket{q}$, meaning there are some complex $a, b, c, d$ so that
\[U_{p,q} = I + (a-1)\ket{p}\bra{p} + b\ket{p}\bra{q}+ c\ket{q}\bra{p}+ (c-1)\ket{q}\bra{q}.\]
For example in a system of two qubits, with $p = 1$ and $q = 2$:
\[U_{1,2} = \begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & a & b & 0 \\
0 & c & d & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}\]
This operation will have no effect on computational basis states $\ket{0}\ket{0}$ or $\ket{1}\ket{1}$, but will act on $\ket{p_2}\ket{p_1}$ and $\ket{q_2}\ket{q_1}$ in a similar manner to
\[U_2 = \begin{bmatrix}
a & b \\
c & d
\end{bmatrix}\]

The proof that any unitary can be represented as a product of such two-level unitaries amounts to a kind of row reduction on the lower left triangle of the unitary, choosing the $c$ value of each $U_{p,q}$ in order to eliminate each element one at a time. We won't present the exact details here, since this part requires no change in the case of a mixed quantum computer. The full procedure can of course be found in \cite{textbook}.

These two-level unitaries can then be implemented as a series of controlled operations $\{C_c(U_2)\}$, which can in turn be decomposed into `basic' operations, $C(X)$ along with arbitrary $U_2 \in U(2)$. This decomposition is done using a variety of techniques presented in \cite{cnot-decomposition}. This set of techniques provide an excellent starting point for reasoning about quantum computation at the level of physical qubits, but in order to work with logical qubits one can go a step further and approximately implement all of $U(2)$ using only two basic gates with known fault tolerant implementations. This result was shown in \cite{universal-qubit}, and shall inform our later discussion in \ref{} of minimal gate sets in quantum computers consisting only of qubits and qutrits.

\section{Representing Two-Level Unitaries With Control Operations}
Once we have decomposed a unitary into two-level unitaries $U_{p,q}$, acting on computational basis states $\ket{p}$ and $\ket{q}$, our next goal will be to represent this two-level unitary as a concrete quantum circuit consisting of various controlled operations. First, we must choose any qubit in the system, which will be indexed by an integer $j$ satisfying $d_j = 2$. Now define $C_c(U_j)$ to be the control operation applying 
\[U_2 = \begin{bmatrix}
a & b \\
c & d
\end{bmatrix}\]
to qubit $j$, so long as every other object in the quantum system is in state $q_i$. In our notation this means
\[c = \{\ket{r_n}\dots\ket{r_1}\ |\ r_i = q_i \text{\ whenever\ } i \neq j\}\]

Now $C_c(U_j)$ will also be a two-level unitary, acting on
\[p' = q_n \dots q_{j+1} 0 q_{j-1} \dots q_1,\]
\[q' = q_n \dots q_{j+1} 1 q_{j-1} \dots q_1.\]
Formally,
\[C_c(U_j) = I + (a-1)\ket{p'}\bra{p'} + b\ket{p'}\bra{q'}+ c\ket{q'}\bra{p'}+ (c-1)\ket{q'}\bra{q'}.\]

Consider our $U_{1,2}$ example. We could choose $j = 1$. Then $p'_2 = q'_2 = q_2 = 1$, so $p'$ and $q'$ would have binary expansion $10$ and $11$, the integers 2 and 3 respectively. This gives
\[C_c(U_j) = C_{r_2=1}(U_j) = \begin{bmatrix}
	1 & 0 & 0 & 0 \\
	0 & 1 & 0 & 0 \\
	0 & 0 & a & b \\
	0 & 0 & c & d
\end{bmatrix}.
\]

At this point we can fairly easily see how to implement $U_{1,2}$ as a concrete quantum circuit, so long as we can map $\ket{p}=\ket{1}$ to $\ket{p'} = \ket{2}$ and $\ket{q}=\ket{2}$ to $\ket{q'}=\ket{3}$. There are two permutation matrices that will do this:
\[P = \begin{bmatrix}
	1 & 0 & 0 & 0 \\
	0 & 0 & 0 & 1 \\
	0 & 1 & 0 & 0 \\
	0 & 0 & 1 & 0
\end{bmatrix}, \begin{bmatrix}
	0 & 0 & 0 & 1 \\
	1 & 0 & 0 & 0 \\
	0 & 1 & 0 & 0 \\
	0 & 0 & 1 & 0
\end{bmatrix}\]

We choose the latter of these, which happens to map any $\ket{r}$ to $\ket{r+1 \mod 4}$, and can be represented by the following circuit:

\begin{quantikz}
\lstick{$\ket{r_2}$} & \qw & \targ{} & \qw \rstick[wires=2]{$\ket{r+1 \mod 4}$} \\
\lstick{$\ket{r_1}$} & \gate{X_2} & \phase{0} \vqw{-1} & \qw  \\
\end{quantikz}

As a matrix expression this is $P = (I \otimes X_2)C_{r_1=0}(X_2 \otimes I)$. Since each term in this circuit is self-inverse, we can reverse the circuit to implement $P^{-1}$ as well. Then in order to apply $U_{p,q}$ to $\ket{r}$, we first apply $P$, then $C_c(U_j)$, then $P^{-1}$, which is the following similarity transformation:
\[\begin{bmatrix}
	1 & 0 & 0 & 0 \\
	0 & a & b & 0 \\
	0 & c & d & 0 \\
	0 & 0 & 0 & 1
\end{bmatrix} = \begin{bmatrix}
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1 \\
1 & 0 & 0 & 0
\end{bmatrix}
\begin{bmatrix}
	1 & 0 & 0 & 0 \\
	0 & 1 & 0 & 0 \\
	0 & 0 & a & b \\
	0 & 0 & c & d
\end{bmatrix}
\begin{bmatrix}
0 & 0 & 0 & 1 \\
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0
\end{bmatrix}.\]
As a quantum circuit this is:

\begin{quantikz}
\lstick[wires=2]{$\ket{\phi}$} & \qw & \targ{} & \phase{1} \vqw{1} & \targ{} & \qw & \qw \rstick[wires=2]{$U_{p,q}\ket{\phi}$} \\
 & \gate{X_2} & \phase{0} \vqw{-1} & \gate{U_2} & \phase{0} \vqw{-1} & \gate{X_2} & \qw
\end{quantikz}

To generalize this we must describe a process for generating and implementing $P$ in any qubit computer. The process given in \cite{textbook} is to implement the transposition $S_{p,p'}$ mapping $\ket{p}$ to $\ket{p'}$. For them this will do as a permutation $P$ since they assume $q'_j = q_j$ as opposed to our assumption that $q'_j = 1$. Consider as an extreme example where $n=3$, and $j=1$, where all three bits need to be inverted, i.e.\ $p_3 \neq q_3$, $p_2 \neq q_2$, $p_1 = q_1$:

\begin{quantikz}
	\lstick{$\ket{r_3}$} & \targ{} & \phase{q_3}\vqw{1} & \phase{q_3}\vqw{1} & \phase{q_3}\vqw{1} & \targ{} & \qw \\
	\lstick{$\ket{r_2}$} & \phase{p_2}\vqw{-1} & \targ{} & \phase{q_2}\vqw{1} & \targ{} & \phase{p_2}\vqw{-1} & \qw \\
	\lstick{$\ket{r_1}$} & \phase{p_1}\vqw{-1} & \phase{p_1}\vqw{-1} & \targ{} & \phase{p_1}\vqw{-1} & \phase{p_1}\vqw{-1} & \qw
\end{quantikz}

In the circuit for $PC_c(U_j)P^{-1}$ the latter half of the above sequence of operations would have no effect, since it would be transforming the action of $C_c(U_2)$ on basis vectors that it doesn't do anything to, so in fact the full circuit simplifies to a circuit that looks much like the above:

\begin{quantikz}
	\lstick{$\ket{r_3}$} & \targ{} & \phase{q_3}\vqw{1} & \phase{q_3}\vqw{1} & \phase{q_3}\vqw{1} & \phase{q_3}\vqw{1} & \phase{q_3}\vqw{1} & \targ{} & \qw \\
	\lstick{$\ket{r_2}$} & \phase{p_2}\vqw{-1} & \targ{} & \phase{q_2}\vqw{1} & \phase{q_2}\vqw{1} & \phase{q_2}\vqw{1} & \targ{} & \phase{p_2}\vqw{-1} & \qw \\
	\lstick{$\ket{r_1}$} & \phase{p_1}\vqw{-1} & \phase{p_1}\vqw{-1} & \targ{} & \gate{U_2} & \targ{} & \phase{p_1}\vqw{-1} & \phase{p_1}\vqw{-1} & \qw
\end{quantikz}

The first half of this is essentially the $P$ we originally wanted, mapping $\ket{p}$ to $\ket{p'}$ and $\ket{q}$ to $\ket{q'}$. This process is fine for showing universal computation in the abstract, but is hard to generalize to mixed contexts, and is generally very wasteful. Instead we shall do something much simpler, using only $C(X)$. The first step shall be to choose a smaller permutation $P_1$ so that $p_j$ maps to 0 and $q_j$ maps to 1. There are four cases to consider:
\begin{itemize}
	\item $p_j = 0$, $q_j = 1$ already,
	\item $p_j = 1$, $q_j = 0$
	\item $p_j = q_j = 0$
	\item $p_j = q_j = 1$
\end{itemize}
In the first case we can set $P_1 = I$, and do nothing, and in the second case we can set $P = X_j$, but in the last two cases we must pick some $k$ so that $p_k \neq q_k$. Then if we are in the third case we set $P = C_{r_k = q_k}(X_j)$, and in the fourth case $P = C_{r_k = p_k}(X_j)$. Now $P_1\ket{q} = \ket{q'}$, so all that remains is to map each remaining $p_i$ to $q_i$ without changing $\ket{q}$. This is simple to do with $C_{r_j=0}(X_i)$, repeated once for each $i\neq j$ with $p_i \neq q_i$. Applied to $\ket{p}$ this will change $p_j$ to $0$, setting the control value, so that the remaining bits can be set to $\ket{q_i}$, and of course applied to $\ket{q}$ this will change $q_j$ to $1$, making no other changes since the control bit has been set incorrectly.

Applied to our extremal three-qutrit example this will look like the following:

\begin{quantikz}
	\lstick{$\ket{r_3}$} & \qw & \qw & \targ{} & \phase{q_2}\vqw{1} & \targ{} & \qw & \qw & \qw \\
	\lstick{$\ket{r_2}$} & \phase{p_2}\vqw{1} & \targ{} & \qw & \phase{q_2}\vqw{1} & \qw & \targ{} & \phase{p_2}\vqw{1} & \qw \\
	\lstick{$\ket{r_1}$} & \targ{} & \phase{0}\vqw{-1} & \phase{0}\vqw{-2} & \gate{U_2} & \phase{0}\vqw{-2} & \phase{0}\vqw{-1} & \targ{} & \qw
\end{quantikz}

In this case our circuit is the same length, or even longer if more optimization had been applied, but the simplification from three Toffoli gates to three $C(X)$ gates is dramatic once we start representing Toffoli gates in terms of $C(X)$, and as the number of bits increases this difference will increase quadratically, so it is a significant improvement. Of course arguments about universal computation are not intended to be efficient anyway, and the real purpose of this approach is to generalize to mixed systems. The way that we do this is straight forward. We still choose $j$ to be some qubit, meaning $d_j = 2$ still. $P_1$ is chosen by the same process as before as well, but if $k$ needs to be chosen it can be an arbitrary control digit whether binary or otherwise. Now to change the remaining digits $p_i$ to $q_i$, we still use controlled operations, but can choose whether we use $C_{r_j=0}(S_{p_i,q_i})$ to change $p_i$, or $C_{r_j=0}(X_{d_i})^{q_i-p_i}$, depending on which basis of \ref{} we are aiming to use.

We have now written $U_{p,q}$ as a combination of control operations, and so next is to use the techniques described in \cite{cnot-decomposition} to decompose these into operations with only a single control object. Of course with the above technique most of our operations are already in this form, but this doesn't eliminate any potential cases, since we still have an arbitrary $C_c(U_j)$ in the middle of the circuit.

\subsection{Decomposing Control Operations}
We would like to decompose $C_c(U_j)$ into elements of $U(2)$ and operations of the form $C(X_{d_i})$ or $C(S_{p_i,p'_i})$. In a binary computer this is done in three steps. The first is to introduce/require an additional $n-3$ auxiliary qubits to the quantum computer that are not intended to be affected by the original unitary in $U(N)$ or the control operation in question, and to inductively reduce the operation $C_c(U_j)$ into a series of gates with two control qubits. We index the new qubits $n+1$ through $2n-2$, which begin and end this process in the computational basis state $\ket{0}$. The key to this process is the Toffoli gate, which [we recall? I've already been talking about them...] is simply a controlled $X$ operation with two control bits, $C_{r_k=q_k,r_l=q_l}(X_j)$.

Take $I$ to be the set of indices $i$ for which our control operation $C_c(U_j)$ has a constraint $r_i = q_i$, so that
\[c = \{\ket{r_1}\dots\ket{r_n}\ |\ r_i = q_i \text{\ whenever} i \in I\}\]
Then we shall perform induction on the size of $I$, implementing any control operation as $2\ord{I}-4$ Toffoli gates, sandwiching a final single- or double-controlled operation $C_{r_k=q_k, r_l=q_l}(U_j)$. Informally this looks like the following:

\begin{quantikz}
\lstick{$\ket{0}$}  & \qw & \qw \midstick[6,brackets=none]{=}& \targ{} & \phase{1}\vqw{4} & \targ{} & \qw \rstick{$\ket{0}$}\\
\lstick{$\ket{r_k}$}& \phase{q_k}\vqw{1} & \qw& \phase{q_k}\vqw{-1} & \qw & \phase{q_k}\vqw{-1} & \qw \rstick{$\ket{r_k}$} \\
\lstick{$\ket{r_l}$}& \phase{q_l}\vqw{2} & \qw& \phase{q_l}\vqw{-1} & \qw & \phase{q_l}\vqw{-1} & \qw \rstick{$\ket{r_l}$} \\
\lstick{$\vdots$}& & & & & & \rstick{$\vdots$} \\
                 & \ctrl{1} & \qw& \qw & \ctrl{1} & \qw & \qw  \\
\lstick{$\ket{r_j}$}& \gate{U_j} & \qw& \qw & \gate{U_j} & \qw & \qw
\end{quantikz}

In total this implements an operation with $\ord{I}$ control bits in terms of one with $\ord{I}-1$ control bits. Formally we have introduced an auxiliary qubit $r_i$, and reduced $I$ to
\[I' = (I \backslash \{k, l\})\cup \{i\}\]
Correspondingly, set $q_i = 1$ and reduce the condition set $c$ to
\[c' = \{\ket{r_1}\dots\ket{r_n}\ |\ r_i = q_i \text{\ whenever} i \in I'\}\]
This returns us to the form we started in, with an operation $C_{c'}(U_j)$, but with one less control qubit. Eventually we will reach a base case where $\ord{I} = 2$, in which case $C_c(U_j)$ is already a double-controlled gate sandwiched by $2\ord{i}-4 = 0$ Toffoli gates. This means that inductively we end up with the result that we wanted.

This decomposition into Toffoli gates acting on auxiliary qubits generalizes to mixed logic without any modification, so long as auxiliary qubits are available. Alternatively one can copy \cite{multi-valued-logic} which introduces auxiliary objects of dimension $d>2$, and uses singly-controlled permutations gates, though controlled increments will do as well. We will assume $d=3$ but it is easy to optimize the number of auxiliary objects when $d$ is larger. The transformation instead looks like this:

\begin{quantikz}
	\lstick{$\ket{0}$}  & \qw & \qw \midstick[6,brackets=none]{=}& \gate{S_{0,1}} & \gate{S_{1,2}} & \phase{2}\vqw{4} & \gate{S_{2,1}} & \gate{S_{1,0}} & \qw \rstick{$\ket{0}$}\\
	\lstick{$\ket{r_k}$}& \phase{q_k}\vqw{1} & \qw& \phase{q_k}\vqw{-1} & \qw & \qw & \qw & \phase{q_k}\vqw{-1} & \qw \rstick{$\ket{r_k}$} \\
	\lstick{$\ket{r_l}$}& \phase{q_l}\vqw{2} & \qw& \qw & \phase{q_l}\vqw{-2} & \qw & \phase{q_l}\vqw{-2} & \qw & \qw \rstick{$\ket{r_l}$} \\
	\lstick{$\vdots$}& & & & & & & & \rstick{$\vdots$} \\
	& \ctrl{1} & \qw& \qw & \qw & \ctrl{1} & \qw & \qw & \qw  \\
	\lstick{$\ket{r_j}$}& \gate{U_j} & \qw& \qw & \qw & \gate{U_j} & \qw & \qw & \qw
\end{quantikz}

$S_{0,1}$ in the above diagram can be replaced with $X_3$ and $S_{1,0}$ with $X^{-1}$ to achieve the same effect, depending on the desired basis. If we have arbitrarily many qutrits or higher available, then we can ignore the Toffoli gates altogether, and only use the $C(X)$ or $C(S_{p_i,p'_i})$ gates available to us to reduce $C_c(U_k)$ to a singly-controlled $C_{r_i=2}(U_j)$, but for generality we shall continue as if Toffoli gates need to be used as well. Given $V_j^2 = U_j$, \cite{cnot-decomposition} presents the following circuit for any $C_{r_k=q_k, r_l=q_l}(U_j)$:

\begin{quantikz}
	\lstick{$\ket{r_k}$}& \phase{q_k}\vqw{1} & \qw\midstick[3,brackets=none]{=}& \qw & \phase{q_k}\vqw{1} & \qw & \phase{q_k}\vqw{1} & \phase{q_k}\vqw{2} & \qw \rstick{$\ket{r_k}$} \\
	\lstick{$\ket{r_l}$}& \phase{q_l}\vqw{1} & \qw& \phase{q_l}\vqw{1} & \targ{} & \phase{q_l}\vqw{1} & \targ{} & \qw & \qw \rstick{$\ket{r_l}$} \\
	\lstick{$\ket{r_j}$}& \gate{U_j} & \qw& \gate{V_j} & \qw & \gate{V_j^{-1}} & \qw & \gate{V_j} & \qw
\end{quantikz}

This decomposes our many doubly-controlled gates into singly-controlled gates, but interestingly all of the Toffoli gates acting on auxiliary qubits will become $C(\sqrt{X_2})$\footnote{If one wants a square root of $X$, then $(H^{-1}\sqrt{Z}H)^2 = H^{-1}ZH = X$ is a simple example, with $\sqrt{Z}\ket{i} = \omega_4^i\ket{i}$.} rather than $C(X)$. So long as object $j$ is still a qubit, this proof will generalise to a mixed quantum computer as follows:

\begin{quantikz}
	\lstick{$\ket{r_k}$}& \phase{q_k}\vqw{1} & \qw\midstick[3,brackets=none]{=}& \qw & \phase{q_k}\vqw{1} & \qw & \phase{q_k}\vqw{1} & \phase{q_k}\vqw{2} & \qw \rstick{$\ket{r_k}$} \\
	\lstick{$\ket{r_l}$}& \phase{q_l}\vqw{1} & \qw& \phase{q_l}\vqw{1} & \gate{S_{q_l,q_l+1}} & \phase{q_l}\vqw{1} & \gate{S_{q_l+1,q_l}} & \qw & \qw \rstick{$\ket{r_l}$} \\
	\lstick{$\ket{r_j}$}& \gate{U_j} & \qw& \gate{V_j} & \qw & \gate{V_j^{-1}} & \qw & \gate{V_j} & \qw
\end{quantikz}

Once again $S_{q_l,q_l+1}$ and $S_{q_l+1,q_l}$ can be replaced with $X_{d_l}$ and $X_{d_l}^{-1}$ depending on the desired basis.

In fact \cite{cnot-decomposition} generalizes this implemention of doubly-controlled gates directly to arbitrary $C_c(U_j)$, so this approach could be directly generalized to a mixed context by replacing all $X_2$ operations with increment/decrement respectively, avoiding the discussion of auxiliary qubits or qutrits altogether, but requiring greater circuit depth in place of the shorter circuit length. This gives a total of three distinct ways of implementing $C_c(U_j)$ in terms of singly-controlled operations $C_{r_k=q_k}(U_j)$, acting on qubits. In all three cases we now need only demonstrate how to implement these in terms of single-qubit unitaries and $C_{r_k=q_k}(X_2)$, which in this case is the same as $C_{r_k=q_k}(S_{0,1})$. The qubit construction referenced in \cite{cnot-decomposition} works for this purpose without modification:

\begin{quantikz}
\lstick{$\ket{r_k}$} & \phase{q_k} & \qw\midstick[2,brackets=none]{=}& \qw & \phase{q_k}\vqw{1} & \qw & \phase{q_k}\vqw{1} & \qw & \qw \rstick{$\ket{r_k}$}\\
\lstick{$\ket{r_j}$} & \gate{U_j} & \qw & \gate{A} & \targ{} & \gate{B} & \targ{} & \gate{C} & \qw
\end{quantikz}

where $A,B,C \in U(2)$ are chosen so that $ABC=I$ and $AXBXC = U_j$. This can be done in general, via the spherical geometry of $U(2)/U(1) \cong SO(3)$[define!], as shown in \cite{cnot-decomposition}. Combining all of the steps just described we have proven \ref{}, generalizing the universality result of \cite{cnot-decomposition} and \cite{textbook} to mixed quantum computers with at least one qubit, and with significantly fewer operations than \cite{textbook} seems to have used, even in the case of a computer with only qubits available. $\square$
\section{Analysing Small Permutations}
We have reduced $U(N)$ to a finite number of generator elements we would like to target. By setting $d_i \in \{2, 3\}$ we have a generator of 12 operations, 4 single object operations
\[H_2, T, X_2, X_3\]
and 8 permutation matrices acting on pairs of objects
\[C_2(X_2), C_2(S_{0,1}), C_2(S_{0, 2}), C_2(S_{1, 2}), C_3(X_2), C_3(S_{0, 1}), C_3(S_{0, 2}), C_3(S_{1, 2})\}\]
where $C_2(\dots)$ is taken to constrain some qubit to the value 1, and $C_3(\dots)$ some qutrit to the value 3. [could define this explicitly in notation section, $C_2$ and $C_d$ also]

We can construct $X_2$ in the usual way, as $H_2T^4H_2$, so we can remove this from the generator set. Further when a matrix $A_j$ acts on the target digit, and hence has no effect on the control digit of a control operation $C_c(B_j)$ we can make many reductions using the relation
\[A_jC_c(B_j)A_j^{-1} = C_c(A_jB_jA_j^{-1})\]
Since when the condition is not satisfied the left hand side will have the effect of $A_jIA_j^{-1}$ i.e.\ no effect, just like the right hand side, and when the condition is satisfied both sides will have the effect $A_jB_jA_j^{-1}$.

[why not just explicitly take all these gates to act on hypothetical 2-object systems from now on, either $\mathbb{C}^4$, $\mathbb{C}^6$, or $\mathbb{C}^9$]

This lets us remove most of the control objects targeting qutrits:
\begin{align*}
	C_d(S_{0, 2}) = C_d(X_3^{-1}S_{0,1}X_3) = X_3^{-1}C_d(S_{0,1})X_3
	\\
	C_d(S_{1, 2}) = C_d(X_3S_{0,1}X_3^{-1}) = X_3C_d(S_{0,1})X_3^{-1}
\end{align*}
We have now reduced our generator set to 7:
\[H_2, T, X_3, C_2(X_2), C_2(S_{0, 1}), C_3(X_2), C_3(S_{0, 1})\]

It is hard to speculate on what a good generator would be without properly considering the physical constraints and trade-offs of a specific computer, but it would not be surprising if $C_2(X_3)$ was more favourable to implement than $C_2(S_{0, 1})$, [suddenly realizing that when turning 2-level unitary into controlled operation we could have used any permutation! which means I could have targeted $C(X)$ from the start! I should consider drawing out the entire discussion of universality into parallel discussions of transposition vs incrementation, since they seem equivalent at every level, not just this one.] and while it is easy to implement $C_d(X_3)$ as $C_d(S_{0,1})C_d(S_{1,2})$, [this is another neat control identity to generalise] it isn't obvious how the reverse might be done. We will later find by brute force that
\[C_2(S_{0,1}) = C_3(X_2) C_2(X_3)^{-1} C_3(X_2) C_2(X_3) C_3(X_2)\]

A decomposition that is likely much less useful than the above is that we can implement $X_3$ as $X_2C_2(X_3)X_2C_2(X_3)$, which increments a qutrit on the condition that a qubit is $\ket{1}$, and then flips that qubit before repeating, ultimately incrementing the qutrit regardless of the state of the qubit. We are going to assume that $X_3$ is significantly easier to implement than $C_2(X_3)$, since $X_3$ only acts on one object, and is not only Clifford, but Pauli, and hence will almost always be implemented before any other operations in the target quantum computer.

This means we have one of two generator sets, either the transposition based set
\[\{H_2, T, X_3, C_2(X_2), C_2(S_{0, 1}), C_3(X_2), C_3(S_{0, 1})\}\]
or the increment based set
\[\{H_2, T, X_3, C_2(X_2), C_2(X_3), C_3(X_2), C_3(X_3)\}\]
[we haven't given an argument for $C_3(S_{0,1})$ in terms of $C_3(X_3)$, hopefully I'll start using increments the whole way through the universality argument, but otherwise you can use an auxiliary qubit and do $C_3(X_2)C_2(S_{0,1})C_3(X_2)$]

Either way we would have 7 gates to implement and then work with. All of the examples we have seen of universal computation for qubits or qutrits has involved some number of Clifford gates, and a single non-Clifford gate, but in order to generalize the standard binary model of quantum computation we find we require 3 additional control gates, none of which are Clifford. [I should probably show that $C_3(X_3)$ is not Clifford..........] As we saw in \cite{tolar-clifford}, there are no Clifford operations that act dependently between a qubit and a qutrit, so it is not clear how easy or valuable it would be to minimize the number of non-Clifford gates used in a mixed logic systems. This prompts a search for other finite groups that act on mixed qubit-qutrit systems.
