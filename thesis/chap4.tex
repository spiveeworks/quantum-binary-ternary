% chap4.tex (Chapter 4 of the thesis)

\chapter[FINITELY GENERATED UNITARY GROUPS]{FINITELY GENERATED UNITARY GROUPS}

\section{Finite Gate Sets in Higher Dimensions}
In the previous chapter we outlined the Pauli matrices, and defined the related Weyl-Heisenberg and Clifford groups, including the matrix $H$ satisfying $H^{-1}ZH = X$. We saw above that $H$ was one of 3 gates needed for universal computation in a binary quantum computer, but the other two are also directly related to the Pauli matrices. $C(X)$ is of course the controlled version of the $X$ gate, and $T$ when applied four times is equivalent to $Z$:
\[
T^4 = \left[\begin{matrix}
	1 & 0 \\
	0 & \frac{1}{\sqrt{2}}(1+i)
\end{matrix}\right]^4 = \left[\begin{matrix}
	1 & 0 \\
	0 & -1
\end{matrix}\right] = Z\]

It turns out that generalizing the Pauli matrices to $d$-dimensional quantum objects as we have done previously proves very useful in describing higher dimensional systems as well, and the relationships that different quantum gates have with each other in these systems.

First of all, the Clifford group formed by taking the normaliser of the Weyl-Heisenberg group lets us generalize the algebraic relationships of $H$ as well as $D = T^2$ to higher dimensions, and looking at \cite{tolar-clifford} will tell us how this group will behave in quantum computers with multiple objects of different dimension.

Additionally the $T$ gate, which does not directly appear in the Clifford group, proves essential to the generalization of universal computation to other quantum systems. In the qubit case the produce $TH^{-1}TH$ is an infinite order matrix, which was proven in \cite{pi-over-eight}, so we outline the technique used to show this, since this means that $T$ and $H$ generate [define this] an infinite group, even with scale factors removed, a property that is necessary for universal computation, and that distinguishes $T$ from the rest of the Clifford group. Additionally we discuss a paper \cite{pi-over-eight} which generalizes this gate $T$ to higher dimensions based on other algebraic relationships it has with the Clifford group.
\subsection{On Clifford Groups}
The paper \cite{tolar-clifford} describes the Clifford group associated with quantum systems with just a single object, as well as the Clifford group associated with arbitrary composite quantum systems, with multiple objects each of different dimension, and in particular for a system with two objects of different dimension. This last case is of particular interest since, as with the $C(X_2)$ gate used in binary quantum computers, gates that only interact with 1 or 2 objects are often easier to implement than those that interact with more. [and might generate the rest anyway, don't know how to justify that though]

Tolar removes the scalar factors from both the Weyl-Heisenberg group, and the Clifford group, not just by taking the group quotient $G/U(1)$, but also by looking at the group conjugation action, mapping the Weyl-Heisenberg group to itself under the map
\[\text{Ad}_A(X^jZ^k) = AX^jZ^kA^{-1}\]
\ [note Tolar uses $\text{Ad}_X$ and uses $Q$ and $P$ for clock and shift respectively] These conjugation maps form a group under function composition, and are isomorphic to the corresponding quotient groups $H(n)/U(1)$ and $N(H(n))/U(1)$. When applied to the Weyl-Heisenberg group associated with a single quantum object of arbitrary dimension, it was shown that $N(H(n))/U(1)$ was isomorphic to
\[(\mathbb{Z}_n\times\mathbb{Z}_n)\rtimes\text{SL}(2,\mathbb{Z}_n)\]

This isomorphism by itself is not new, [can I reference something older then?] and can be used to generate the Clifford group (up to global phase) with the four matrices $X_d$, $Z_d$, $D_d$, and $H_d$, [apparently I'm using $d$ now] defined by:
[insert definition... maybe put these generators up in preliminaries, with an older reference]

The more significant result of the paper however, was the extension to Clifford groups for arbitrary composite systems. The Weyl-Heisenberg group of a composite system $C^{d_1}\otimes \dots \otimes C^{d_n}$ [have we defined Kronecker products of spaces?] is taken to be the product of Weyl-Heisenberg groups acting on each individual system:
\[H(d_1, \dots, d_n) = \{A_1 \otimes \dots \otimes A_n\ |\ A_i \in H(d_i)\} \cong H(d_1) \times \dots \times H(d_n)\]
\ [this isn't the notation used in Tolar, it's our own.]

While this composite Weyl-Heisenberg group consists only of Kronecker products, [I want to use the word dependent, need to mention that in the Kronecker product section] its normalizer can contain operations that are not Kronecker products, for example
\[\text{CNOT} = C(X) = \left[\begin{matrix}
	1 & 0 & 0 & 0 \\
	0 & 1 & 0 & 0 \\
	0 & 0 & 0 & 1 \\
	0 & 0 & 1 & 0
\end{matrix}\right] \in N(H(2, 2))\]

The Clifford groups of non-mixed composite systems have been explored elsewhere, [have they? where?] but here Tolar showed a number of results for mixed systems, the most important of these for us was that in a composite system $\mathbb{C}^m \otimes \mathbb{C}^n$ with $gcd(m, n) = 1$, the quotient of the Clifford group is simply the direct product of the corresponding single-object Clifford groups:
\[N(H(m, n))/U(1) \cong N(H(m))/U(1) \times N(H(n))/U(1) \]
This means that the Clifford group is \emph{not} capable of acting dependently between quantum objects, making it much less powerful than in non-mixed systems.

The same paper also showed that when $m$ and $n$ have square or cubic divisors in common, that the corresponding Clifford groups are novel in a way unlike any non-mixed quantum system. This is interesting in the broader context of mixed logic, but will not be relevant to our later discussion of $\mathbb{C}^2 \otimes \mathbb{C}^3$.

This is the only paper we found that looks at quantum systems with objects of differing dimension.

\subsection{Infinite-Order Gates}
In our outline of how universal computation is achieved for binary quantum computers, the last step was to decompose unitary operations acting on one qubit, into a sequence of $H$ and $T$ operations. The technique for doing this was described in \cite{universal-qubit}, and involved constructing a pair of operations which each rotate the Bloch sphere by irrational portions of a full $2\pi$ rotation each in a different, orthogonal plane. By iterating one of these rotations, one can approximate any angle in the unit circle, and thus with each of these rotations implemented, one can implement any rotation of the Bloch sphere as 3 successive rotations made using these gates.

One of the facts that makes the Clifford group algebraically and theoretically significant is that up to scale factors it is finite, whereas any group containing both $T$ and $H$ must not be finite, or else the rotations that were generated with them would be finite order, i.e.\ a rational fraction of a $2\pi$ rotation in their respective planes. This means the technique by which these rotations were shown to be irrational/infinite order are significant in both of these contexts, in working out alternate conditions for universal computation in different quantum systems, and in analysing the order of different subgroups of $U(n)$ in search of finite groups.

The technique they use for showing this is to generate an expression for the angle of rotation, $2\pi \theta$ say, then to show that the unit complex number $e^{i2\pi \theta}$ is not a root of unity, i.e. that $\theta$ is rational. This can be done by leveraging the algebraic number theory of cyclotomic polynomials, with the following theorem proven in an appendix of their paper:

[capital T theorem] For any $\theta \in \mathbb{R}$, $\theta$ is rational if and only if $e^{i2\pi \theta}$ is the root of a minimal [vs irreducible?] polynomial with rational coefficients.

This analysis works well in the Bloch sphere all unitary matrices will represent a single rotation in some plane, but when dealing with more complicated geometries we can still apply this kind of analysis if we look at the eigenvalues of a given matrix instead. Given a unitary matrix $A$, we already know that its eigenvalues are unit complex numbers $e^{i 2\pi\theta}$, so then

[capital P proposition?] the following are equivalent:
\begin{itemize}
	\item $A$ is finite order
	\item Every eigenvalue of $A$ is finite order under multiplication, i.e.\ is a root of unity
	\item Every eigenvalue of $A$ is a root of a cyclotomic polynomial
\end{itemize}

Now the eigenvalues of $A$ will be roots of the characteristic polynomial $det(A - \lambda I)$, so if the characteristic polynomial has rational coefficients then we can work directly with this to show that $A$ is of finite or infinite order.

Now $e^{i 2\pi\theta}$ and $e^{-i 2\pi\theta}$ are both eigenvalues of the rotation
\[R(2\pi \theta) = \left[\begin{matrix}
	\cos(2\pi\theta) & -\sin(2\pi\theta) \\
	\sin(\theta) & \cos(\theta)
\end{matrix}\right]\]
so in this way \cite{universal-qubit} was already dealing with eigenvalues, and we simply generalize this. That said \cite{universal-qubit} deals with rotations of the Bloch sphere, which means the eigenvalues of the original operation being considered might be different to this. Further, the Bloch sphere is designed to remove global phase factors, and so an operation like $e^{i2\pi\theta}I$ will act trivially on the Bloch sphere, whereas under our eigenvalue analysis this operation might have infinite order despite being trivial in practice. This means that if we want to show that a matrix has infinite order, then we must show that some scalar multiple of it has some eigenvalues which are roots of unity, and others which are not. For example let $\theta$ be irrational, so that the unit complex number $e^{i2\pi\theta}$ is not a root of unity, then
\[A = \left[\begin{matrix}
	e^{i2\pi\theta} & 0 \\
	0 & e^{-i2\pi\theta}
\end{matrix}\right]\]
will be infinite order, but so will any non-zero scalar multiple $\lambda A$, since if $\lambda e^{i2\pi\theta}$ is a root of unity, then $\lambda = e^{i2\pi(\phi - \theta)}$ with $\phi$ rational, meaning that $\lambda e^{-i2\pi\theta}$ still won't be a root of unity, and vice versa.
\subsection{Qudit versions of the qubit ``pi-over-eight'' gate}
In searching for a generalization of the $T$ gate from binary to higher dimensions, there are a number of properties that could be used to find such gates. For example one could naively define the family of gates:
\[T_n = Z_n^{1/4} = \left[\begin{matrix}
	1 & 0 & 0 & \dots & 0 \\
	0 & \omega_{4n} & 0 & \dots & 0 \\
	0 & 0 & \omega_{4n}^2 & \dots & 0 \\
	\vdots & \vdots & \vdots & \ddots & \vdots \\
	0 & 0 & 0 & \dots & \omega_{4n}^{n-1} \\
\end{matrix}\right]\]

This takes the defining property of $T$ and generalizes it, which is exactly what we do to define the rest of the objects defined in this thesis. In this case however, it is much more useful to generalize two other properties that $T$ has, properties which are not unique to $T$, but which are essential for its power in discussions of universal computation. The first property is that $T$ is diagonal. The equation $T^4 = Z$ seems to be a coincidence of low dimension, rather than a general property of the diagonal matrices of interest to us. The second property is that $T$ is in the second level of the Clifford hierarchy, as defined in \cite{clifford-hierarchy}:

[capital D definition] The Clifford hierarchy is an infinite sequence of sets $\mathcal{C}_i$ where $\mathcal{C}_1$ is the Pauli group, $\mathcal{C}_2$ is the Clifford group, and generalizing this
\[\mathcal{C}_{i+1} = \{A\ |\ A\mathcal{C}_1A^{-1} \subseteq \mathcal{C}_i\}\]
Note that only the first two levels of this hierarchy form groups, the rest are simply different sets of unitary matrices.
[do we have cosets and double cosets?]

We see that for qubits, $T \in \mathcal{C}_3$, and so to generalize $T$ to any prime dimension $p$, the paper \cite{pi-over-eight} finds the full (finite) solution set $\{U_v\}$ satisfying $U_v \in \mathcal{C}_3$, $U_v$ diagonal. Global phase is also removed by assuming that $U_v\ket{0} = \ket{0}$. They also show that this solution set forms a group, analyze this group to determine its structure and minimum number of generators. Additionally they explore the geometric properties of these generalized gates, and use this to argue for the strength of these generalized gates as being optimally resistant to multiple forms of noise in physical implementations.

When exploring the group theoretic structure of these solution sets, they found that $p = 2$ and $p = 3$ gave groups that were generated by $1$ and $2$ elements respectively, whereas for $p \geq 5$ there were always $3$ generator elements. This also appears to be a coincidence of low dimension akin to the relation $T^4 = Z$. In addition to both of these properties of low dimension, the paper \cite{arithmetics} shows that $P_9 \in \mathcal{C}_3$ along with the rest of the Clifford group $\mathcal{C}_2$ can be used to exactly generate \emph{all} of the permutation matrices in a system made of multiple qutrits, and interestingly $P_9$ can be scaled to satisfy the relation $P_9^3 = Z_3$.

%\chapter[CALCULATION IN BINARY-TERNARY]{Calculation in Binary-Ternary}
[seems like the chapters we really want are universal computation, finite groups, and then maybe the ternary arithmetic/magic state/fault tolerant stuff?? might be a big restructure, and hides the fact that understanding the background material is not just a means to an end in this document, but an end of this document in itself.]

[explain the context we infer from the previous discussion: interesting work on non-binary computation, esp. ternary, but very small amounts on mixed computation, meaning we ought to start with the absolute basics... maybe also speculate on what the trade-offs of the different number systems seem to be?]

\section{Programmatic Search for Finite Groups}
Normally the Clifford group is an excellent tool for reasoning about quantum systems, since it is finite, (up to scalar factors [I should be careful about my previous statements about generators of the Clifford group, maybe define what a `finite Clifford group' is]) and cheap to implement, but somehow maximal in that one can add just a single gate to achieve universal computation. We saw in \cite{tolar-clifford}, however, that the Clifford group only introduces operations that act dependently between objects when the dimensions of those objects have a common factor, which 2 and 3 do not share, essentially splitting a mixed binary-ternary quantum computer into two separate computers, with two separate Clifford groups, only able to communicate via non-Clifford operations. There is no reason why this can't be done, but there isn't a clear advantage either, so in this section we will take the generators of the Clifford group,
\[X_2, Z_2, H_2, D_2, X_3, Z_3, H_3, D_3,\]
[have I defined $H_d$ and $D_d$?]
and different combinations of permutation matrix, starting with $C_2(X_3)$ and $C_3(X_2)$, to create different generators of subgroups of $U(6)$. We implement a breadth first search in the groups generated by these sets using the C programming language, and find some combinations which yield finite groups, and others that cannot be fully enumerated without crashing due to integer overflow, which we will present and discuss.

The first group we will discuss is the one generated by removing $H_2$ and $H_3$ from the generator set, and adding both $C_2(X_3)$ and $C_3(X_2)$ in their place. All of these generators sit inside of the generalized symmetric group
\[\{AB\ |\ A\text{\ diagonal}, A^6 = I, A \in U(6), B \in \mathcal{S}_6\}\]
[define in general, and prove this is a group, presumably in the groups discussion where we needed examples of normal subgroups anyway]
which means that they generate some subgroup of this.

In fact $X_2$, $X_3$, $C_2(X_3)$ and $C_3(X_2)$ will turn out to generate the whole symmetric group on 6 elements, so having them all would be quite powerful for computation, but now we run into a conjugate problem, which is that our group has a way of doing nontrivial things with entangled states, but no longer any way of creating states other than simple multiples of the computational basis! This generalized permutation group provides essential operations, but isn't much more powerful than the Pauli group without $H_2$ or $H_3$, so our primary focus will be understanding the trade-offs between different combinations of $H_2$, $H_3$, $C_3(X_2)$, and $C_2(X_3)$.
\subsection{Representing Complex Matrices in C}
It would be standard to use some algebraic program or package such as Magma to solve this problem, but because our goal is simple enough to implement in a handful of sittings, it was just as easy to implement it from scratch in C, yielding a program that is simple, high performance, and easy to customize. The full source code of this program is given in Appendix C, and was tested using the Tiny C Compiler, but run using the Clang compiler with optimization level 2. We will now outline the techniques used, since they are of independent interest. 

The first obstacle in not using an algebraic package is the exact representation of numbers whose binary expansion never terminates or repeats, for example the sixth root of unity
\[\omega_6 = e^{\frac{i\pi}{3}} = \frac{\sqrt{3}}{2} + \frac{1}{2}i\]
To solve this we aim to represent the field extension
\begin{align*}
	\text{Num} = \mathbb{Q}[\sqrt{-1}, \sqrt{2}, \sqrt{3}]
	&= \left\{ \sum_{j,k,l = 0}^1 n_{jkl}\ i^j\left(\sqrt{2}\right)^k\left(\sqrt{3}\right)^l
	\ \middle|\ n_{jkl} \in \mathbb{Q}\right\}
\end{align*}
using an array of 32-bit integers, eight signed integers representing the numerator in $\mathbb{Z}[\dots]$, and one unsigned ineger for the denominator.

We have a few basic operations to define in Num, the most significant of which are multiplication, and inverses. We implement these algorithms naively, and since these are the most fundamental building blocks of our program, this will lead to very bad performance without optimization, (in fact we found the program runs four times worse, 20 seconds vs 5 seconds) but when the search is going to take numerous seconds anyway, the additional second or two of optimization is less painful than it would be in other projects.

For multiplication in Num, we implement multiplication in $\mathbb{Z}[X, Y, Z]$, [oh no do I have to define field extensions? Might as well throw it in the appendix I guess] iterating 6 variables over the range ${0, 1}$ according to the equality
\begin{align*}
	\left(\sum_{j,k,l = 0}^1 a_{jkl}X^jY^kZ^l\right)\left(\sum_{j,k,l = 0}^1 b_{jkl}X^jY^kZ^l\right)
	\\= \sum_{j_1,k_1,l_1=0}^1\sum_{j_2,k_2,l_2=0}^1 a_{j_1k_1l_1}b_{j_2k_2l_2}X^{j_1+j_2}Y^{k_1+k_2}Z^{l_1+l_2}
\end{align*}
, then we make three reductions, according to the rules $x^2 = -1$, $y^2 = 2$, and $z^2 = 3$, returning us to Num. When calculating the product of two elements of Num we generally also divide out any common factors of the nine integers in our representation, so that each number has a unique 36 byte representation in memory.

To calculate the inverse of $a \in \text{Num}$, we set $x_0 = a$ and $y_0 = 1$, make repeated modifications of the form $x_{j+1} = x_jc_j$, $y_{j+1} = y_jc_j$. In this way we eventually get $x_k = 1$, while preserving the identity $x_j = ay_j$, meaning $y_k = a^{-1}$. We set $c_0$ to the denominator of $x_0$ so that $x_1 \in \mathbb{Z}[i, \sqrt{2}, \sqrt{3}]$, then remove each radical by setting $c_k$ to the conjugate of $x_k$. That is $c_1$ is $x_1$ but with $i$ replaced by $-i$, so that $x_2 \in \mathbb{Z}[\sqrt{2}, \sqrt{3}]$. Repeating for $\sqrt{2}$ gives $x_3 \in \mathbb{Z}[\sqrt{3}]$, and then repeating for $\sqrt{3}$ gives $x_4 \in \mathbb{Z}$. Now we can set $c_4 = 1/x_4$ to get $x_5 = 1$ and hence $y_5 = a^{-1}$. For example if $a = \omega_{6} = (\sqrt{3} + i)/2$, then the process looks like this:
\begin{align*}
	x_0 &= (\sqrt{3} + i)/2 & y_0 &= 1 & c_0 &= 2 \\
	x_1 &= \sqrt{3} + i & y_1 &= 2 & c_1 &= \sqrt{3}-i \\
	x_2 &= 4 & y_2 &= 2\sqrt{3}-2i & c_2 &= 4 \\
	x_3 &= 16 & y_3 &= 8\sqrt{3}-8i & c_3 &= 16 \\
	x_4 &= 256 & y_4 &= 128\sqrt{3}-128i & c_4 &= 1/256 \\
	x_5 &= 1 & y_5 &= (\sqrt{3}-i)/2 & \\
\end{align*}
In practice we could have stopped earlier, in fact for any root of unity it will be enough to multiply by the complex conjugate, but checking for these conditions for early termination is very likely to be slower for a CPU than to simply finish the calculation as we have above.

Next we represent a complex matrix as a $6\times 6$ array of Num, taking a total of 1296 bytes per matrix! Matrix multiplication is defined in the usual way, by setting $c_{ik} = \sum_j a_{ij}b_{jk}$, but reduced matrix multiplication was also defined, where the matrix is scaled so that the first non-zero entry of the matrix is exactly 1. We also represent a permutation in $\mathcal{S}_6$ as 6 bytes, representing a lookup table of a map $\{1\dots 6\} \to \{1 \dots 6\}$.

\subsection{The Search Algorithm}
We now have an implementation of two groups, $GL(6, \text{Num})$, [define $GL$] and $\mathcal{S}_6$, so now we can implement the search itself. The search has six non-optional parameters:
\begin{enumerate}
	\item \verb`gen_len` the amount of `letters' in the generator set
	\item \verb`gen`, the array of letters, each of type \verb`void*`
	\item \verb`names`, string data to print when describing new words that were found
	\item \verb`elem_size`, the size in memory of an element of the group
	\item \verb`compose`, a binary operation acting on group elements
	\item \verb`print_elem`, a procedure to display the group element (matrix or permutation) that has been generated
\end{enumerate}
The search then generates an array of \verb`PathNode`s, (named after the geometric interpretation of groups as `Cayley graphs' [I could change the source code so that I don't need to explain the weird names!]) which are tuples containing
\begin{itemize}
	\item the word length of the corresponding element generated
	\item a pointer to an earlier \verb`PathNode`, called the predecessor; may be \verb`NULL`
	\item the leftmost letter of the word, which when added to the predecessor gives the current word in question
	\item a \verb`void*` pointer to the unique group element that was found, called \verb`result`
\end{itemize}
The procedure also prints each object as it generates them, for example:
\begin{verbatim}
	X3 D2 X2:
	0, 0, 0, 0, 0, -i, 
	0, 0, 0, -i, 0, 0, 
	0, 0, 0, 0, -i, 0, 
	0, 0, 1, 0, 0, 0, 
	1, 0, 0, 0, 0, 0, 
	0, 1, 0, 0, 0, 0, 
\end{verbatim}

The algorithm itself is a breadth first search, where the array of \verb`PathNode`s is also used as the queue of elements not yet searched. The array is initialized to contain the letters themselves, as words of length 1 with no predecessor, and a pointer \verb`curr` is initialized to the start of the array. Then new group elements are generated via \verb`compose(gen[i], curr->result)`, checked for uniqueness, and if they are unique they are appended to the array. Once \verb`curr` reaches the end of the array, we will have proven that the group is finite, and have enumerated all of its elements.

Checking uniqueness becomes quite slow, the biggest group that was exhaustively generated had 165888 matrix elements, meaning the minimum number of matrix comparisons needed would have been 13759331328, which is like comparing 16 terabytes of data, one kilobyte at a time. In order to overcome this we also implement an open addressed hash map, using a technique called Robin Hood hashing. [quick reference for this I guess!] The hash map takes the \verb`void*` corresponding to the group element in question, and generates a hash by literally shuffling bits around using the XOR and SHIFT operations offered in C. The hash is then used as an offset into an additional array, called the hash table, where another pointer to the group element will be stored. When a new group element is calculated, rather than search for that group element within a whole megabyte of existing elements, we simply calculate its hash, and check if the element we are looking for is in the correct location in the hash table.

Things are complicated when two group elements correspond to the same location in the hash table, which is where the lookup algorithm must `probe' for other locations near the offset associated with the hash, to store the new entries there instead. Robin hood hashing/probing is a small optimization on this concept, allowing entries to be moved again after being written the first time, to make room for other entries that would otherwise end up too far from their original offset; minimizing this `probe distance' from the original offset of a hash entry makes lookups faster, especially as the hash table becomes full. Another technical detail is the fact that since we never remove entries from the hash table, and only run the program once before exiting, we don't need to allocate, reallocate, ore remove entries from the hash table; we simply use a global block of memory, and implement lookup and insert procedures, and we are done.

With this technology in place, all that remains is to wire it together, with definitions for \verb`compose`, and \verb`print_elem`. For permutations, we compose $x$ and $y$ by setting \verb`xy[i] = x[y[i]]`, and for matrices we multiply, and divide out the first non-zero scale factor, essentially implementing the quotient group $U(6)/U(1)$. We also check the order of the matrix, as a simple heuristic for detecting infinite order groups; If we can calculate the order without causing an integer overflow then we continue generating the group, but if any of the 324 integers in our matrix representation are above some threshold, we assume the order is infinite, represented by \verb`-1`, and print this fact, to indicate that the search is unlikely to terminate. We actually continue regardless of the order, since it might be worth knowing which words of similar size have infinite order as well.

\subsection{Results}
Call the six generators of the Clifford group other than $H_2$ and $H_3$ the reduced generator set $R$. [we haven't defined generators at all!] Then $\langle R, H_2, H_3 \rangle$ is a finite Clifford group, and $\langle R, C_2(X_3), C_3(X_2) \rangle$ is a subgroup of the generalized symmetric group and therefore finite as described previously, but additionally, $\langle R, H_2, C_3(X_2)\rangle$ and $\langle R, H_3, C_2(X_3)\rangle$ are finite. [suddenly realizing that the orbits of these groups would be easier to analyze than the groups themselves, since the orbits implicitly quotient out permutations on the computational basis, and by removing global phase matrices will have no effect on their eigenvectors as well]

The last two generators we could consider, $\langle R, H_2, C_2(X_3)\rangle$, and $\langle R, H_3, C_3(X_2)\rangle$, both trigger an integer overflow when calculating the order of the products $C_2(X_3)H_2$, and $C_3(X_2)H_3$.

The exact values of these matrices are
\begin{align*}
	C_2(X_3)H_2 &=
	\frac{1}{\sqrt{2}}
	\begin{bmatrix}
		1&0&0&0&0&0\\
		0&1&0&0&0&0\\ 
		0&0&1&0&0&0\\ 
		0&0&0&0&0&1\\ 
		0&0&0&1&0&0\\ 
		0&0&0&0&1&0
	\end{bmatrix}
	\begin{bmatrix}
		1&0&0&1&0&0\\ 
		0&1&0&0&1&0\\ 
		0&0&1&0&0&1\\ 
		1&0&0&-1&0&0\\ 
		0&1&0&0&-1&0\\ 
		0&0&1&0&0&-1
	\end{bmatrix}
	\\&=
	\frac{1}{\sqrt{2}}
	\begin{bmatrix}
		1&0&0&1&0&0\\ 
		0&1&0&0&1&0\\ 
		0&0&1&0&0&1\\ 
		0&0&1&0&0&-1\\ 
		1&0&0&-1&0&0\\ 
		0&1&0&0&-1&0
	\end{bmatrix}
\end{align*}
For a $6\times6$ matrix this seems fairly innocuous, and the other doesn't look much worse
\begin{align*}
	C_3(X_2)H_3 &=
	\frac{1}{\sqrt{3}}
	\begin{bmatrix}
		1&0&0&0&0&0\\
		0&1&0&0&0&0\\ 
		0&0&0&0&0&1\\ 
		0&0&0&1&0&0\\ 
		0&0&0&0&1&0\\ 
		0&0&1&0&0&0
	\end{bmatrix}
	\begin{bmatrix}
		1&1&1&0&0&0\\ 
		1&\omega_3&\omega_3^2&0&0&0\\ 
		1&\omega_3^2&\omega_3&0&0&0\\ 
		0&0&0&1&1&1\\ 
		0&0&0&1&\omega_3^2&\omega_3\\ 
		0&0&0&1&\omega_3&\omega_3^2
	\end{bmatrix}
	\\&=
	\frac{1}{\sqrt{3}}
	\begin{bmatrix}
		1&0&0&0&0&0\\
		0&1&0&0&0&0\\ 
		0&0&0&0&0&1\\ 
		0&0&0&1&0&0\\ 
		0&0&0&0&1&0\\ 
		0&0&1&0&0&0
	\end{bmatrix}
	\begin{bmatrix}
		1&1&1&0&0&0\\ 
		1&\frac{-1 +\sqrt{3}i}{2}&\frac{-1 -\sqrt{3}i}{2}&0&0&0\\ 
		1&\frac{-1 -\sqrt{3}i}{2}&\frac{-1 +\sqrt{3}i}{2}&0&0&0\\ 
		0&0&0&1&1&1\\ 
		0&0&0&1&\frac{-1 +\sqrt{3}i}{2}&\frac{-1 -\sqrt{3}i}{2}\\ 
		0&0&0&1&\frac{-1 -\sqrt{3}i}{2}&\frac{-1 +\sqrt{3}i}{2}
	\end{bmatrix}
	\\&=
	\frac{1}{\sqrt{3}}
	\begin{bmatrix}
		1&1&1&0&0&0\\ 
		1&\omega_3&\omega_3^2&0&0&0\\
		0&0&0&1&\omega_3^2&\omega_3\\ 
		0&0&0&1&1&1\\ 
		0&0&0&1&\omega_3&\omega_3^2\\
		1&\omega_3^2&\omega_3&0&0&0
	\end{bmatrix}
\end{align*}
[keeping the middle entry for now for Symbolab]

But if we raise the simpler of these to the fourth power, it becomes quite chaotic:
\[\left(C_2(X_3)H_2\right)^4 =
\frac{1}{4}
\begin{bmatrix}
	2&-1&3&0&-1&1\\ 
	3&2&-1&1&0&-1\\ 
	-1&3&2&-1&1&0\\ 
	-1&1&0&3&-1&2\\ 
	0&-1&1&2&3&-1\\ 
	1&0&-1&-1&2&3
\end{bmatrix}
\]

The second power is $C_2(X_3)H_2C_2(X_3)H_2$, which resembles the infinite order term from \cite{universal-qubit}, a non-Clifford matrix, times the Fourier transform of that matrix, [I haven't explained why I call it the Fourier transform of the matrix] and when we ask Wolfram Mathematica for its characteristic polynomial we get
\[1/4 (\lambda - 1)^2 (4 \lambda^4 + 2 \lambda^3 - 3 \lambda^2 + 2 \lambda + 4)\]
This rational polynomial has an irreducible factor that is cyclotomic and another that is non-cyclotomic, which by the reasoning used in \cite{universal-qubit} tells us that as we expected, one of its eigenvalues is a root of unity, and another is not, meaning no scale multiple of this matrix is finite order, and so $\langle R, H_2, C_2(X_3) \rangle$ really is an infinite group. Further $C_2(X_3)H_2$ is also infinite order, since two of its eigenvalues will square to roots of unity, and are therefore also roots of unity, whereas the other four will square to non-roots of unity, and are therefore also not roots of unity.

Inspired by this, we could calculate
\[C_3(X_2) H_3^{-1} C_3(X_2) H_3 =
\frac{1}{3} \begin{bmatrix}
	2 & \omega_6 & \omega_6^2 & 1 & \omega_6^4 & \omega_6^5 \\
	\omega_6^2 & 2 & \omega_6 & \omega_6^5 & 1 & \omega_6^4 \\
	\omega_6^4 & \omega_6^5 & 1 & \omega_6 & \omega_6^2 & 2 \\
	1 & \omega_6^4 & \omega_6^5 & 2 & \omega_6 & \omega_6^2 \\
	\omega_6^5 & 1 & \omega_6^4 & \omega_6^2 & 2 & \omega_6 \\
	\omega_6 & \omega_6^2 & 2 & \omega_6^4 & \omega_6^5 & 1
\end{bmatrix}
\]
[a. I still need Mathematica up before I can get a polynomial for this b. this doesn't necessarily have the novelty of the $H_2$ case? I don't know the geometry]

There are 720 different permutations in $\mathcal{S}_6$, 12 of which are already in the Clifford group, and we have shown manually that one of the remaining 708 is infinite order when multiplied with $H_2$. It is quite difficult to prove that a matrix is infinite order using this method, especially when it isn't sparse the way $H_2$ is, and often the characteristic polynomial has $\sqrt{2}$ or $\sqrt{3}$ coefficients which would require deeper number theory than we have presented here, so we return now to the search for matrices that we can prove are finite order. We can write another C program extending the existing codebase to exhaustively generate all $6^6$ tables of integers, and generate matrices for the $720$ that are permutations. Then we attempt to calculate the order of $P H_2$ and $P H_3$, and report when either or both have a finite order that we could calculate. Other than the 12 Clifford permutations, the only $P$ for which both $P H_2$ and $P H_3$ were finite order were the 12 matrices of the form
\[X_2^a C_2(S_{p,q}) X_2^b\text{\ where\ }a, b \in \{0, 1\}, p, q \in \{0, 1, 2\}, p \neq q.\]
This seems promising, but in fact such $P$ will still have $\langle P, H_2, H_3\rangle$ infinite order, since $P H_3^2 = P S_{1,2}$ will not be in the above form, meaning $\langle P, H_2, H_3 \rangle$ is still infinite order, and so the only time where $\langle P, H_2, H_3 \rangle$ can be finite is if $P \in \mathcal{C}_2$ anyway, meaning $P$ is simply the Kronecker product of a qubit operation and a qutrit operation. [need to emphasise this a little more, maybe just theorem it, something I'm going to do anyway]

The final result of this program is that we can use it to check that
\[\langle X_2, C_3(X_2), X_3, C_2(X_3) \rangle = \mathcal{S}_6,\]
This is how we know that
\[C_2(S_{p,q}) \in \langle X_2, C_3(X_2), X_3, C_2(X_3) \rangle\]
which is where we found the word for $C_2(S_{p,q})$ given in \ref{}. Additionally since we have $C_2(X_3) = C_2(S_{0,1})X_3C_2(S_{0,1})X_3$, we can infer that
\[\langle X_2, C_3(X_2), X_3, C_2(S_{0,1})\rangle = \mathcal{S}_6\]
also. These results are interesting but it is important not to forget about the qubit-qubit and qutrit-qutrit control gates which were essential for universal computation, which are concealed by this myopic discussion of $U(6)$.

\subsection{Non-Clifford States}
[I should be talking about magic states sooner as a part of fault tolerance computation and as a motivation for having finite gate sets, I could write some stuff about the following circuits but I need to know what I've actually set up at this point]

\begin{quantikz}
	\lstick{qubit $\ket{0}$} & \gate{H} & \gate{T} & \targ{} & \qw \rstick{$\ket{0}+\omega_4\ket{1}$}\\
	\lstick{qubit $\ket{\phi}$} & \qw & \qw & \phase{0}\vqw{-1} & \qw \rstick{$\omega_4^3T\ket{\phi}$}
\end{quantikz}

\begin{quantikz}
	\lstick{qubit $\ket{0}$} & \gate{H_2} & \phase{1} \vqw{1} & \gate{H_2} & \meter{0/1} & \qw\rstick{$\ket{0}$ or $\ket{1}$}\\
	\lstick{qutrit $\ket{0}$} & \qw & \targ{} & \qw & \qw & \qw \rstick{$\ket{+_{0,1}}$ or $\ket{-_{0,1}}$}
\end{quantikz}

\begin{quantikz}
	\lstick{qubit $\ket{0}$} & \qw & \targ{} & \meter{0/1} & \qw \rstick{$\ket{0}$ or $\ket{1}$} \\
	\lstick{qutrit $\ket{0}$} & \gate{H_3} & \phase{2} \vqw{-1} & \qw & \qw \rstick{$\ket{+_{0,1}}$ or $\ket{2}$}
\end{quantikz}